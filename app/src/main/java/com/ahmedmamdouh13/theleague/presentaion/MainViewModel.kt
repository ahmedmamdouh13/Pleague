package com.ahmedmamdouh13.theleague.presentaionimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.Observerimport androidx.lifecycle.ViewModelimport com.ahmedmamdouh13.theleague.domain.interactor.MatchesInteractorimport com.ahmedmamdouh13.theleague.presentaion.mapper.ModelMapperimport com.ahmedmamdouh13.theleague.presentaion.model.MatchScheduleModelimport io.reactivex.android.schedulers.AndroidSchedulersimport io.reactivex.disposables.Disposableimport io.reactivex.schedulers.Schedulersimport javax.inject.Injectclass MainViewModel @Inject constructor(    matchesInteractor: MatchesInteractor,    modelMapper: ModelMapper) : ViewModel() {    private val useCase = matchesInteractor    private val mapper = modelMapper    val matchesScheduleLiveData = MutableLiveData<Map<String,List<MatchScheduleModel>>>()    val matchesFavoriteLiveData = MutableLiveData<List<MatchScheduleModel>>()    val daysNumberLiveData = MutableLiveData<String>()    val dateChangedLiveData = MutableLiveData<String>()    val checkToggleListener: MutableLiveData<MatchScheduleModel> = MutableLiveData()    val unCheckToggleListener: MutableLiveData<Int> = MutableLiveData()    val matchesState: MutableLiveData<UiState> = MutableLiveData()    private val disposables = arrayListOf<Disposable>()    init {        disposables.add(useCase.getFavoriteMatches()            .subscribeOn(Schedulers.io())            .observeOn(AndroidSchedulers.mainThread())            .subscribe {list ->                matchesFavoriteLiveData.postValue( list.map {                    println("${it.favorite} ${it.id}")                    mapper.mapDomainToModel(it)                })            })    }   fun initMatches() {        matchesState.value = UiState.Loading       disposables.add( useCase.getMatches()            .observeOn(AndroidSchedulers.mainThread())            .subscribe { l , e ->                matchesState.postValue(UiState.Success)                matchesScheduleLiveData.value =                    l.mapValues { list ->                    list.value.map {                        mapper.mapDomainToModel(it)                    }                }            })//    }    fun daysUntilMatch(date: String) {        daysNumberLiveData.value = useCase.getDaysUntilDate(date)        dateChangedLiveData.value = date    }    val checkObserver = Observer<MatchScheduleModel>{ model ->            useCase.favoriteFixture(mapper.mapModelToDomain(model))    }    val unCheckObserver = Observer<Int>{ id ->            useCase.unFavoriteFixture(id)    }    override fun onCleared() {        for(d in disposables){            if (!d.isDisposed)                d.dispose()        }        super.onCleared()    }}